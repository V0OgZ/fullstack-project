# ðŸŒŒ PANOPTICON - SPEC COMPLÃˆTE POUR MEMENTO/CLAUDIUS
*Vision de Grut - Projection 5D â†’ 3D â†’ 2D*

---

## ðŸŽ¯ **VISION D'ENSEMBLE**

Le Panopticon n'est pas un simple dashboard - c'est une **interface de jeu alternative** qui permet de :
- Visualiser le World State Graph complet en 5D
- Jouer des scÃ©narios depuis une perspective omnisciente
- Comprendre les causalitÃ©s et superpositions quantiques
- Projeter intelligemment 5D â†’ 3D â†’ 2D sur l'Ã©cran

### **Connexion avec le GROFI**
Le Panopticon EST la visualisation du GROFI (Graph of Reality Organized by Fog and Immunities). Il montre :
- Les nÅ“uds du graphe (Ã©tats du monde)
- Les arÃªtes causales (transitions possibles)
- Le fog de causalitÃ© (zones d'incertitude)
- Les immunitÃ©s temporelles (paradoxes Ã©vitÃ©s)

---

## ðŸ”§ **BACKEND - NOUVELLES API NÃ‰CESSAIRES**

### **1. PanopticonService.java**
```java
@Service
public class PanopticonService {
    
    @Autowired
    private GameService gameService;
    
    @Autowired
    private GrofiCausalIntegrationService grofiService; // Ã€ crÃ©er
    
    @Autowired
    private TemporalEngineService temporalEngine;
    
    /**
     * GÃ©nÃ¨re les donnÃ©es complÃ¨tes pour la visualisation 5D
     */
    public PanopticonData generateVisualizationData(Long gameId) {
        Game game = gameService.findById(gameId);
        
        return PanopticonData.builder()
            .worldStateGraph(grofiService.buildCompleteWSG(game))
            .timelines(extractAllTimelines(game))
            .temporalLayers(buildTemporalLayers(game))
            .causalityZones(calculateAllCausalityZones(game))
            .quantumStates(game.getPsiStates())
            .projectionMode("5D_TO_3D_INTELLIGENT")
            .build();
    }
    
    /**
     * Permet de jouer un scÃ©nario depuis le Panopticon
     */
    public ScenarioResult playScenarioFromPanopticon(
            Long gameId, 
            String scenarioScript,
            Position5D startPosition) {
        
        // Validation des paradoxes
        if (!grofiService.validateCausality(gameId, scenarioScript)) {
            return ScenarioResult.paradox("Action crÃ©erait un paradoxe!");
        }
        
        // ExÃ©cution dans une timeline sandbox
        return temporalEngine.executeInSandbox(gameId, scenarioScript);
    }
    
    /**
     * Projette les coordonnÃ©es 5D en 3D pour Three.js
     */
    public List<Node3D> projectTo3D(List<Position5D> positions) {
        return positions.stream()
            .map(pos -> Node3D.builder()
                .x(pos.getX())
                .y(pos.getY())
                .z(calculateZFromTimeline(pos))
                .color(getTimelineColor(pos.getTimeline()))
                .opacity(calculateTemporalOpacity(pos.getDay()))
                .size(calculateNodeImportance(pos))
                .build())
            .collect(Collectors.toList());
    }
}
```

### **2. GrofiCausalIntegrationService.java** (NOUVEAU)
```java
@Service
public class GrofiCausalIntegrationService {
    
    /**
     * Construit le World State Graph complet
     */
    public WorldStateGraph buildCompleteWSG(Game game) {
        WorldStateGraph wsg = new WorldStateGraph();
        
        // NÅ“uds : tous les Ã©tats possibles
        for (Hero hero : game.getHeroes()) {
            for (int day = 1; day <= game.getCurrentTurn() + 10; day++) {
                for (String timeline : getAccessibleTimelines(hero)) {
                    WSGNode node = createNode(hero, day, timeline);
                    wsg.addNode(node);
                }
            }
        }
        
        // ArÃªtes : transitions causales
        for (WSGNode from : wsg.getNodes()) {
            for (WSGNode to : wsg.getNodes()) {
                if (isCausallyConnected(from, to)) {
                    wsg.addEdge(from, to, calculateCausalWeight(from, to));
                }
            }
        }
        
        return wsg;
    }
    
    /**
     * Calcule le fog de causalitÃ© en 5D
     */
    public double calculateFog5D(Position5D position, String playerId) {
        double fog = 0.0;
        
        // DensitÃ© quantique
        fog += getQuantumDensity(position) * 0.3;
        
        // Distance temporelle
        fog += getTemporalDistance(position, playerId) * 0.3;
        
        // Divergence des timelines
        fog += getTimelineDivergence(position) * 0.2;
        
        // InterfÃ©rences causales
        fog += getCausalInterference(position) * 0.2;
        
        return Math.min(1.0, fog);
    }
}
```

### **3. PanopticonController.java**
```java
@RestController
@RequestMapping("/api/panopticon")
public class PanopticonController {
    
    @Autowired
    private PanopticonService panopticonService;
    
    @GetMapping("/data/{gameId}")
    public PanopticonData getVisualizationData(@PathVariable Long gameId) {
        return panopticonService.generateVisualizationData(gameId);
    }
    
    @PostMapping("/play-scenario/{gameId}")
    public ScenarioResult playScenario(
            @PathVariable Long gameId,
            @RequestBody ScenarioRequest request) {
        return panopticonService.playScenarioFromPanopticon(
            gameId, 
            request.getScript(), 
            request.getStartPosition()
        );
    }
    
    @GetMapping("/projection/{gameId}")
    public ProjectionData getProjection(
            @PathVariable Long gameId,
            @RequestParam String mode) { // "5D", "4D", "3D", "2D"
        return panopticonService.getProjectionByMode(gameId, mode);
    }
    
    @WebSocket("/live/{gameId}")
    public void streamLiveUpdates(Long gameId) {
        // Stream en temps rÃ©el des changements du WSG
    }
}
```

---

## ðŸŽ¨ **FRONTEND - INTERFACE REACT**

### **1. Architecture des Composants**
```typescript
// src/components/panopticon/
â”œâ”€â”€ PanopticonView.tsx          // Container principal
â”œâ”€â”€ WSGVisualizer.tsx           // Visualisation Three.js du graphe
â”œâ”€â”€ DimensionSelector.tsx       // SÃ©lecteur 5Dâ†’4Dâ†’3Dâ†’2D
â”œâ”€â”€ TimelineExplorer.tsx        // Navigation dans les branches
â”œâ”€â”€ CausalityOverlay.tsx        // Affichage des zones causales
â”œâ”€â”€ QuantumStatePanel.tsx       // Ã‰tats Ïˆ et superpositions
â”œâ”€â”€ ScenarioPlayer.tsx          // Interface pour jouer des scÃ©narios
â””â”€â”€ EvadeQuestTracker.tsx       // Progression de la quÃªte philosophique
```

### **2. PanopticonView.tsx**
```typescript
import React, { useState, useEffect } from 'react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';
import WSGVisualizer from './WSGVisualizer';
import DimensionSelector from './DimensionSelector';
import { usePanopticonStore } from '@/store/panopticonStore';

export const PanopticonView: React.FC = () => {
    const [dimension, setDimension] = useState<'5D' | '4D' | '3D' | '2D'>('3D');
    const [selectedTimeline, setSelectedTimeline] = useState<string>('â„¬1');
    const { wsgData, loadWSG } = usePanopticonStore();
    
    useEffect(() => {
        loadWSG(gameId);
    }, [gameId]);
    
    return (
        <div className="panopticon-container">
            <div className="controls-panel">
                <DimensionSelector 
                    current={dimension} 
                    onChange={setDimension}
                />
                <TimelineExplorer 
                    selected={selectedTimeline}
                    onChange={setSelectedTimeline}
                />
            </div>
            
            <div className="visualization-area">
                <Canvas camera={{ position: [0, 50, 100] }}>
                    <ambientLight intensity={0.5} />
                    <pointLight position={[10, 10, 10]} />
                    <WSGVisualizer 
                        data={wsgData}
                        dimension={dimension}
                        timeline={selectedTimeline}
                    />
                    <OrbitControls />
                </Canvas>
                
                <CausalityOverlay data={wsgData.causalityZones} />
            </div>
            
            <div className="info-panels">
                <QuantumStatePanel states={wsgData.quantumStates} />
                <ScenarioPlayer />
                <EvadeQuestTracker progress={getQuestProgress()} />
            </div>
        </div>
    );
};
```

### **3. WSGVisualizer.tsx**
```typescript
import { useFrame } from '@react-three/fiber';
import { useMemo } from 'react';

interface WSGNode {
    id: string;
    position: Position5D;
    type: 'hero' | 'artifact' | 'quantum_state';
    timeline: string;
    day: number;
}

export const WSGVisualizer: React.FC<Props> = ({ data, dimension, timeline }) => {
    const nodes = useMemo(() => {
        return projectNodes(data.nodes, dimension, timeline);
    }, [data, dimension, timeline]);
    
    return (
        <group>
            {/* NÅ“uds du graphe */}
            {nodes.map(node => (
                <WSGNode 
                    key={node.id}
                    position={node.projectedPosition}
                    color={getNodeColor(node)}
                    size={getNodeSize(node)}
                    opacity={getNodeOpacity(node, dimension)}
                />
            ))}
            
            {/* ArÃªtes causales */}
            {data.edges.map(edge => (
                <CausalEdge
                    key={edge.id}
                    from={edge.from}
                    to={edge.to}
                    strength={edge.causalWeight}
                    animated={edge.isActive}
                />
            ))}
            
            {/* Plans temporels */}
            {dimension === '5D' && (
                <TemporalPlanes 
                    days={data.temporalLayers}
                    opacity={0.1}
                />
            )}
        </group>
    );
};
```

### **4. Modes de Visualisation**

#### **Mode 5D (Complet)**
- X, Y : Position spatiale
- Z : Jour (temporal layer)
- Couleur : Timeline (â„¬1=bleu, â„¬2=rouge, etc.)
- Taille : Importance causale
- Transparence : Certitude (opaque=confirmÃ©, transparent=superposÃ©)

#### **Mode 4D (Sans altitude)**
- Fusionne Z avec le temps
- Utilise des anneaux temporels autour des positions

#### **Mode 3D (Spatial + Temps)**
- Projection isomÃ©trique classique
- Temps reprÃ©sentÃ© par des halos colorÃ©s

#### **Mode 2D (Vue Ã‰vadÃ© Cave)**
- Projection "ombres sur le mur"
- Montre ce que voient les joueurs normaux

### **5. Interactions SpÃ©ciales**

```typescript
// ScenarioPlayer.tsx
export const ScenarioPlayer: React.FC = () => {
    const [script, setScript] = useState('');
    const { executeScenario } = usePanopticonStore();
    
    const handlePlay = async () => {
        const result = await executeScenario(script);
        if (result.paradox) {
            showParadoxWarning(result.message);
        } else {
            animateScenarioExecution(result.steps);
        }
    };
    
    return (
        <div className="scenario-player">
            <h3>Jouer un ScÃ©nario depuis le Panopticon</h3>
            <textarea 
                value={script}
                onChange={(e) => setScript(e.target.value)}
                placeholder="Ïˆ001: MOV(Hero, @10,10)..."
            />
            <button onClick={handlePlay}>
                ExÃ©cuter dans le WSG
            </button>
        </div>
    );
};
```

---

## ðŸŽ® **INTÃ‰GRATION AVEC LA QUÃŠTE DE L'Ã‰VADÃ‰**

La quÃªte de l'Ã©vadÃ© de la cave est le **tutoriel philosophique** du Panopticon :

1. **Phase 1** : Le joueur voit le jeu normal (2D iso)
2. **Phase 2** : DÃ©couverte du feu (comprend la projection)
3. **Phase 3** : Sortie de la cave (vue 3D dÃ©bloquÃ©e)
4. **Phase 4** : ComprÃ©hension du temps (vue 4D)
5. **Phase 5** : AccÃ¨s au Panopticon (vue 5D complÃ¨te)

---

## ðŸ“¦ **LIBRAIRIES RECOMMANDÃ‰ES**

### **Frontend**
- **Three.js** / **@react-three/fiber** : Visualisation 3D
- **@react-three/drei** : Helpers Three.js (OrbitControls, etc.)
- **D3.js** : Graphes de force pour le WSG
- **Framer Motion** : Animations fluides entre dimensions
- **Zustand** : State management (dÃ©jÃ  utilisÃ©)

### **Backend**
- **Spring WebFlux** : Pour le streaming temps rÃ©el
- **GraphQL** : RequÃªtes flexibles du WSG (optionnel)
- **JGraphT** : Manipulation de graphes en Java

---

## ðŸš€ **PROCHAINES Ã‰TAPES POUR MEMENTO/CLAUDIUS**

1. **CrÃ©er GrofiCausalIntegrationService** pour construire le WSG
2. **ImplÃ©menter PanopticonService** avec les projections
3. **DÃ©velopper l'interface React** en commenÃ§ant par la vue 3D
4. **IntÃ©grer la quÃªte de l'Ã©vadÃ©** comme tutoriel
5. **Tester avec diffÃ©rents scÃ©narios** temporels

---

*Cette spec respecte la vision de Grut : le Panopticon comme fenÃªtre sur la vraie nature 5D du jeu, avec une progression philosophique de la comprÃ©hension.*