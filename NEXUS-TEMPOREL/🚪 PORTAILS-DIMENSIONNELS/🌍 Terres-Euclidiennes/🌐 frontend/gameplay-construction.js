// gameplay-construction.js - Syst√®me de construction et recrutement
class GameplayConstruction {
    constructor() {
        this.buildings = {
            'CASTLE': {
                name: 'Ch√¢teau',
                icon: 'üè∞',
                cost: { gold: 100, temporalEnergy: 50 },
                requirements: { level: 1 },
                effects: { defense: 3, temporalEnergy: 2 },
                description: 'Forteresse d√©fensive avec bonus d\'√©nergie temporelle'
            },
            'TOWER': {
                name: 'Tour',
                icon: 'üóº',
                cost: { gold: 50, temporalEnergy: 25 },
                requirements: { level: 1 },
                effects: { defense: 2 },
                description: 'Tour de guet d√©fensive'
            },
            'ANCHOR_TOWER': {
                name: 'Tour d\'Ancrage',
                icon: '‚öì',
                cost: { gold: 200, temporalEnergy: 100 },
                requirements: { level: 5 },
                effects: { defense: 1, lockDuration: 5 },
                description: 'Stabilise la timeline et verrouille la zone'
            },
            'BARRACKS': {
                name: 'Caserne',
                icon: '‚öîÔ∏è',
                cost: { gold: 75, temporalEnergy: 30 },
                requirements: { level: 2 },
                effects: { recruitment: true },
                description: 'Permet de recruter des unit√©s militaires'
            },
            'MAGE_TOWER': {
                name: 'Tour de Mage',
                icon: 'üîÆ',
                cost: { gold: 120, temporalEnergy: 60 },
                requirements: { level: 3 },
                effects: { magic: 2, spellResearch: true },
                description: 'Centre de recherche magique et temporelle'
            },
            'QUANTUM_FORGE': {
                name: 'Forge Quantique',
                icon: '‚ö°',
                cost: { gold: 300, temporalEnergy: 150 },
                requirements: { level: 8 },
                effects: { artifactCrafting: true, quantumBonus: 1 },
                description: 'Forge des artefacts quantiques l√©gendaires'
            }
        };
        
        this.units = {
            'WARRIOR': {
                name: 'Guerrier',
                icon: 'üõ°Ô∏è',
                cost: { gold: 20, temporalEnergy: 5 },
                requirements: { building: 'BARRACKS' },
                stats: { attack: 15, defense: 10, health: 80 },
                description: 'Unit√© de base, √©quilibr√©e'
            },
            'ARCHER': {
                name: 'Archer',
                icon: 'üèπ',
                cost: { gold: 25, temporalEnergy: 8 },
                requirements: { building: 'BARRACKS' },
                stats: { attack: 20, defense: 5, health: 60, range: 3 },
                description: 'Attaque √† distance'
            },
            'MAGE': {
                name: 'Mage',
                icon: 'üßô‚Äç‚ôÇÔ∏è',
                cost: { gold: 40, temporalEnergy: 15 },
                requirements: { building: 'MAGE_TOWER' },
                stats: { attack: 25, defense: 3, health: 50, magic: 30 },
                description: 'Lance des sorts puissants'
            },
            'QUANTUM_KNIGHT': {
                name: 'Chevalier Quantique',
                icon: '‚öîÔ∏è',
                cost: { gold: 100, temporalEnergy: 50 },
                requirements: { building: 'QUANTUM_FORGE' },
                stats: { attack: 30, defense: 25, health: 150, quantumArmor: 0.8 },
                description: 'Unit√© d\'√©lite avec armure quantique'
            },
            'PHOENIX': {
                name: 'Ph√©nix Quantique',
                icon: 'ü¶Ö',
                cost: { gold: 200, temporalEnergy: 100 },
                requirements: { building: 'QUANTUM_FORGE' },
                stats: { attack: 35, defense: 15, health: 120, quantumRebirth: true },
                description: 'Cr√©ature l√©gendaire qui rena√Æt'
            }
        };
        
        this.resources = {
            gold: 500,
            temporalEnergy: 200,
            wood: 100,
            stone: 50,
            quantumEssence: 10
        };
        
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        // √âcouter les clics sur la carte pour construction
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('build-button')) {
                this.showBuildingMenu(e.target.dataset.x, e.target.dataset.y);
            }
        });
    }
    
    // Afficher le menu de construction
    showBuildingMenu(x, y) {
        const menu = this.createBuildingMenu(x, y);
        this.showModal(menu, 'Construction');
    }
    
    // Cr√©er le menu de construction
    createBuildingMenu(x, y) {
        let html = `
            <div class="construction-menu">
                <h3>üèóÔ∏è Construction √† (@${x}, ${y})</h3>
                <div class="resources-display">
                    <span>üí∞ ${this.resources.gold}</span>
                    <span>‚ö° ${this.resources.temporalEnergy}</span>
                    <span>ü™µ ${this.resources.wood}</span>
                    <span>ü™® ${this.resources.stone}</span>
                    <span>‚ú® ${this.resources.quantumEssence}</span>
                </div>
                <div class="buildings-grid">
        `;
        
        Object.entries(this.buildings).forEach(([key, building]) => {
            const canAfford = this.canAfford(building.cost);
            const canBuild = this.canBuild(building.requirements);
            const disabled = !canAfford || !canBuild;
            
            html += `
                <div class="building-card ${disabled ? 'disabled' : ''}" 
                     onclick="${disabled ? '' : `this.buildStructure('${key}', ${x}, ${y})`}">
                    <div class="building-icon">${building.icon}</div>
                    <div class="building-info">
                        <h4>${building.name}</h4>
                        <p>${building.description}</p>
                        <div class="building-cost">
                            ${Object.entries(building.cost).map(([resource, amount]) => 
                                `<span class="${this.resources[resource] >= amount ? 'affordable' : 'expensive'}">${this.getResourceIcon(resource)} ${amount}</span>`
                            ).join('')}
                        </div>
                        <div class="building-effects">
                            ${Object.entries(building.effects).map(([effect, value]) => 
                                `<span class="effect">${this.getEffectIcon(effect)} ${effect}: ${value}</span>`
                            ).join('')}
                        </div>
                    </div>
                </div>
            `;
        });
        
        html += `
                </div>
                <div class="construction-actions">
                    <button onclick="this.closeModal()" class="cancel-button">‚ùå Annuler</button>
                </div>
            </div>
        `;
        
        return html;
    }
    
    // Afficher le menu de recrutement
    showRecruitmentMenu(buildingType) {
        const menu = this.createRecruitmentMenu(buildingType);
        this.showModal(menu, 'Recrutement');
    }
    
    // Cr√©er le menu de recrutement
    createRecruitmentMenu(buildingType) {
        let html = `
            <div class="recruitment-menu">
                <h3>‚öîÔ∏è Recrutement - ${this.buildings[buildingType]?.name || buildingType}</h3>
                <div class="resources-display">
                    <span>üí∞ ${this.resources.gold}</span>
                    <span>‚ö° ${this.resources.temporalEnergy}</span>
                </div>
                <div class="units-grid">
        `;
        
        Object.entries(this.units).forEach(([key, unit]) => {
            const canRecruit = this.canRecruitUnit(unit, buildingType);
            const canAfford = this.canAfford(unit.cost);
            const disabled = !canRecruit || !canAfford;
            
            html += `
                <div class="unit-card ${disabled ? 'disabled' : ''}" 
                     onclick="${disabled ? '' : `this.recruitUnit('${key}')`}">
                    <div class="unit-icon">${unit.icon}</div>
                    <div class="unit-info">
                        <h4>${unit.name}</h4>
                        <p>${unit.description}</p>
                        <div class="unit-cost">
                            ${Object.entries(unit.cost).map(([resource, amount]) => 
                                `<span class="${this.resources[resource] >= amount ? 'affordable' : 'expensive'}">${this.getResourceIcon(resource)} ${amount}</span>`
                            ).join('')}
                        </div>
                        <div class="unit-stats">
                            ${Object.entries(unit.stats).map(([stat, value]) => 
                                `<span class="stat">${this.getStatIcon(stat)} ${stat}: ${value}</span>`
                            ).join('')}
                        </div>
                    </div>
                </div>
            `;
        });
        
        html += `
                </div>
                <div class="recruitment-actions">
                    <button onclick="this.closeModal()" class="cancel-button">‚ùå Fermer</button>
                </div>
            </div>
        `;
        
        return html;
    }
    
    // Construire un b√¢timent
    async buildStructure(buildingType, x, y) {
        const building = this.buildings[buildingType];
        if (!building) {
            console.error('B√¢timent inconnu:', buildingType);
            return;
        }
        
        if (!this.canAfford(building.cost)) {
            this.showMessage('‚ùå Ressources insuffisantes!', 'error');
            return;
        }
        
        if (!this.canBuild(building.requirements)) {
            this.showMessage('‚ùå Conditions non remplies!', 'error');
            return;
        }
        
        // Consommer les ressources
        this.spendResources(building.cost);
        
        // Appeler l'API backend
        try {
            const response = await fetch(`/api/temporal/games/${window.gameAPI.gameId}/script`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    script: `BUILD(${buildingType}, @${x},${y})`
                })
            });
            
            const result = await response.json();
            if (result.success) {
                this.showMessage(`‚úÖ ${building.name} construit avec succ√®s!`, 'success');
                this.closeModal();
                // Rafra√Æchir l'√©tat du jeu
                if (window.gameplayEnhancement) {
                    window.gameplayEnhancement.refreshGameState();
                }
            } else {
                this.showMessage(`‚ùå Erreur: ${result.error}`, 'error');
                // Rembourser les ressources
                this.addResources(building.cost);
            }
        } catch (error) {
            console.error('Erreur construction:', error);
            this.showMessage('‚ùå Erreur de connexion', 'error');
            // Rembourser les ressources
            this.addResources(building.cost);
        }
    }
    
    // Recruter une unit√©
    async recruitUnit(unitType) {
        const unit = this.units[unitType];
        if (!unit) {
            console.error('Unit√© inconnue:', unitType);
            return;
        }
        
        if (!this.canAfford(unit.cost)) {
            this.showMessage('‚ùå Ressources insuffisantes!', 'error');
            return;
        }
        
        // Consommer les ressources
        this.spendResources(unit.cost);
        
        // Appeler l'API backend
        try {
            const response = await fetch(`/api/temporal/games/${window.gameAPI.gameId}/script`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    script: `RECRUIT(${unitType}, 1, HERO:${window.gameplayEnhancement?.selectedHero?.name || 'Arthur'})`
                })
            });
            
            const result = await response.json();
            if (result.success) {
                this.showMessage(`‚úÖ ${unit.name} recrut√© avec succ√®s!`, 'success');
                this.closeModal();
                // Rafra√Æchir l'√©tat du jeu
                if (window.gameplayEnhancement) {
                    window.gameplayEnhancement.refreshGameState();
                }
            } else {
                this.showMessage(`‚ùå Erreur: ${result.error}`, 'error');
                // Rembourser les ressources
                this.addResources(unit.cost);
            }
        } catch (error) {
            console.error('Erreur recrutement:', error);
            this.showMessage('‚ùå Erreur de connexion', 'error');
            // Rembourser les ressources
            this.addResources(unit.cost);
        }
    }
    
    // V√©rifier si on peut se permettre le co√ªt
    canAfford(cost) {
        return Object.entries(cost).every(([resource, amount]) => 
            this.resources[resource] >= amount
        );
    }
    
    // V√©rifier si on peut construire (niveau requis)
    canBuild(requirements) {
        // Pour l'instant, on suppose que le niveau 1 est toujours disponible
        return true;
    }
    
    // V√©rifier si on peut recruter l'unit√©
    canRecruitUnit(unit, buildingType) {
        return unit.requirements.building === buildingType;
    }
    
    // Consommer des ressources
    spendResources(cost) {
        Object.entries(cost).forEach(([resource, amount]) => {
            this.resources[resource] -= amount;
        });
    }
    
    // Ajouter des ressources (remboursement)
    addResources(cost) {
        Object.entries(cost).forEach(([resource, amount]) => {
            this.resources[resource] += amount;
        });
    }
    
    // Obtenir l'ic√¥ne d'une ressource
    getResourceIcon(resource) {
        const icons = {
            gold: 'üí∞',
            temporalEnergy: '‚ö°',
            wood: 'ü™µ',
            stone: 'ü™®',
            quantumEssence: '‚ú®'
        };
        return icons[resource] || 'üì¶';
    }
    
    // Obtenir l'ic√¥ne d'un effet
    getEffectIcon(effect) {
        const icons = {
            defense: 'üõ°Ô∏è',
            temporalEnergy: '‚ö°',
            lockDuration: 'üîí',
            recruitment: '‚öîÔ∏è',
            magic: 'üîÆ',
            spellResearch: 'üìö',
            artifactCrafting: '‚ö°',
            quantumBonus: '‚ú®'
        };
        return icons[effect] || 'üìä';
    }
    
    // Obtenir l'ic√¥ne d'une statistique
    getStatIcon(stat) {
        const icons = {
            attack: '‚öîÔ∏è',
            defense: 'üõ°Ô∏è',
            health: '‚ù§Ô∏è',
            range: 'üèπ',
            magic: 'üîÆ',
            quantumArmor: '‚ú®',
            quantumRebirth: 'üîÑ'
        };
        return icons[stat] || 'üìä';
    }
    
    // Afficher une modal
    showModal(content, title) {
        const modal = document.createElement('div');
        modal.className = 'game-modal';
        modal.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <h2>${title}</h2>
                    <button onclick="this.closeModal()" class="close-button">√ó</button>
                </div>
                <div class="modal-body">
                    ${content}
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Ajouter la m√©thode closeModal au contexte global
        window.closeModal = () => {
            document.body.removeChild(modal);
        };
    }
    
    // Afficher un message
    showMessage(message, type = 'info') {
        const messageDiv = document.createElement('div');
        messageDiv.className = `game-message ${type}`;
        messageDiv.textContent = message;
        
        document.body.appendChild(messageDiv);
        
        setTimeout(() => {
            if (document.body.contains(messageDiv)) {
                document.body.removeChild(messageDiv);
            }
        }, 3000);
    }
    
    // Mettre √† jour l'affichage des ressources
    updateResourceDisplay() {
        const resourceDisplay = document.querySelector('.resource-display');
        if (resourceDisplay) {
            resourceDisplay.innerHTML = `
                <span>üí∞ ${this.resources.gold}</span>
                <span>‚ö° ${this.resources.temporalEnergy}</span>
                <span>ü™µ ${this.resources.wood}</span>
                <span>ü™® ${this.resources.stone}</span>
                <span>‚ú® ${this.resources.quantumEssence}</span>
            `;
        }
    }
    
    // Ajouter des boutons de construction √† la carte
    addConstructionButtons() {
        const gameCanvas = document.getElementById('game-canvas');
        if (!gameCanvas) return;
        
        // Ajouter des boutons de construction sur la carte
        // Cette m√©thode sera appel√©e apr√®s le rendu de la carte
    }
}

// Export pour utilisation globale
window.GameplayConstruction = GameplayConstruction; 