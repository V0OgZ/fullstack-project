package com.heroesoftimepoc.temporalengine.service;

import com.heroesoftimepoc.temporalengine.model.Game;
import com.heroesoftimepoc.temporalengine.model.Hero;
import com.heroesoftimepoc.temporalengine.model.PsiState;
import com.heroesoftimepoc.temporalengine.model.WorldStateGraph;
import com.heroesoftimepoc.temporalengine.model.SpatialNode;
import com.heroesoftimepoc.temporalengine.model.CausalConnection;
import com.heroesoftimepoc.temporalengine.model.TemporalLayer;
import com.heroesoftimepoc.temporalengine.service.ExtendedTemporalScriptParser.ExtendedScriptResult;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Service d'int√©gration entre la grammaire GROFI √©tendue et le syst√®me de collapse causale
 * G√®re les artefacts d'immunit√©, les effets sp√©ciaux GROFI et la r√©solution des conflits
 */
@Service
public class GrofiCausalIntegrationService {
    
    @Autowired
    private CausalCollapseService causalCollapseService;
    
    @Autowired
    private ExtendedTemporalScriptParser extendedParser;
    
    @Autowired
    private GrofiHeroService grofiHeroService;
    
    /**
     * Traiter un script GROFI avec int√©gration causale compl√®te
     */
    public Map<String, Object> processGrofiScriptWithCausalIntegration(Game game, String script) {
        Map<String, Object> result = new HashMap<>();
        
        try {
            // 1. Parser le script GROFI
            ExtendedScriptResult parseResult = extendedParser.parseExtendedScript(script);
            if (!parseResult.success) {
                result.put("success", false);
                result.put("error", parseResult.error);
                return result;
            }
            
            // 2. V√©rifier les immunit√©s et restrictions AVANT l'ex√©cution
            Map<String, Object> immunityCheck = checkGrofiImmunities(game, parseResult);
            if (!Boolean.TRUE.equals(immunityCheck.get("allowed"))) {
                result.put("success", false);
                result.put("error", "Action bloqu√©e: " + immunityCheck.get("reason"));
                result.put("immunityDetails", immunityCheck);
                return result;
            }
            
            // 3. Calculer l'impact sur le graphe causale AVANT l'ex√©cution
            Map<String, Object> causalImpact = calculateCausalGraphImpact(game, parseResult);
            result.put("causalImpact", causalImpact);
            
            // 4. Ex√©cuter avec protection causale
            Map<String, Object> executionResult = executeWithCausalProtection(game, parseResult);
            result.putAll(executionResult);
            
            // 5. Traiter les collapses causales d√©clench√©s
            List<CausalCollapseService.CollapseResult> triggeredCollapses = 
                processTriggeredCausalCollapses(game, parseResult);
            if (!triggeredCollapses.isEmpty()) {
                result.put("triggeredCollapses", triggeredCollapses.stream()
                    .map(CausalCollapseService.CollapseResult::toString)
                    .collect(Collectors.toList()));
            }
            
            // 6. Mettre √† jour le graphe d'√©tat global
            updateWorldStateGraph(game, parseResult, executionResult);
            
            result.put("grofiIntegration", true);
            result.put("scriptType", parseResult.type);
            result.put("success", true);
            
        } catch (Exception e) {
            result.put("success", false);
            result.put("error", "Erreur int√©gration GROFI-causale: " + e.getMessage());
        }
        
        return result;
    }
    
    /**
     * V√©rifier les immunit√©s GROFI avant l'ex√©cution
     */
    private Map<String, Object> checkGrofiImmunities(Game game, ExtendedScriptResult parseResult) {
        Map<String, Object> result = new HashMap<>();
        result.put("allowed", true);
        
        // V√©rifier selon le type de script
        switch (parseResult.type) {
            case "GROFI_ULTIMATE":
                return checkUltimatePowerImmunities(game, parseResult);
                
            case "ROLLBACK":
            case "ROLLBACK_RANGE":
            case "ROLLBACK_ALL":
                return checkRollbackImmunities(game, parseResult);
                
            case "TOTAL_COLLAPSE":
                return checkCollapseImmunities(game, parseResult);
                
            case "CONDITION":
            case "CONDITION_IF_THEN":
                return checkConditionImmunities(game, parseResult);
                
            default:
                result.put("message", "Pas de restrictions d'immunit√© pour: " + parseResult.type);
        }
        
        return result;
    }
    
    /**
     * V√©rifier immunit√©s pour Ultimate Powers
     */
    private Map<String, Object> checkUltimatePowerImmunities(Game game, ExtendedScriptResult parseResult) {
        Map<String, Object> result = new HashMap<>();
        
        String heroName = (String) parseResult.parameters.get("heroName");
        Hero hero = game.getHeroByName(heroName);
        
        if (hero == null) {
            result.put("allowed", false);
            result.put("reason", "H√©ros non trouv√©: " + heroName);
            return result;
        }
        
        // V√©rifier immunit√© IMMUNE[OBS] sur les autres h√©ros
        List<String> immuneHeroes = new ArrayList<>();
        for (Hero otherHero : game.getHeroes()) {
            if (!otherHero.getName().equals(heroName)) {
                List<String> immunities = grofiHeroService.getHeroImmunities(otherHero);
                if (immunities.contains("OBS") || immunities.contains("COLLAPSE")) {
                    immuneHeroes.add(otherHero.getName());
                }
            }
        }
        
        if (!immuneHeroes.isEmpty()) {
            result.put("allowed", true); // Autoris√© mais avec effet r√©duit
            result.put("warning", "Certains h√©ros sont immunis√©s: " + immuneHeroes);
            result.put("immuneTargets", immuneHeroes);
        } else {
            result.put("allowed", true);
            result.put("message", "Ultimate Power autoris√© - aucune immunit√© d√©tect√©e");
        }
        
        return result;
    }
    
    /**
     * V√©rifier immunit√©s pour Rollback
     */
    private Map<String, Object> checkRollbackImmunities(Game game, ExtendedScriptResult parseResult) {
        Map<String, Object> result = new HashMap<>();
        
        // Chercher les artefacts qui bloquent le rollback
        List<String> blockingArtifacts = new ArrayList<>();
        for (Hero hero : game.getHeroes()) {
            List<String> immunities = grofiHeroService.getHeroImmunities(hero);
            if (immunities.contains("ROLLBACK") || immunities.contains("TEMPORAL")) {
                blockingArtifacts.add(hero.getName() + " (IMMUNE[ROLLBACK])");
            }
        }
        
        if (!blockingArtifacts.isEmpty()) {
            result.put("allowed", false);
            result.put("reason", "Rollback bloqu√© par artefacts: " + blockingArtifacts);
            result.put("blockingArtifacts", blockingArtifacts);
        } else {
            result.put("allowed", true);
            result.put("message", "Rollback autoris√©");
        }
        
        return result;
    }
    
    /**
     * V√©rifier immunit√©s pour Collapse Total
     */
    private Map<String, Object> checkCollapseImmunities(Game game, ExtendedScriptResult parseResult) {
        Map<String, Object> result = new HashMap<>();
        
        // Compter les √©tats prot√©g√©s
        int protectedStates = 0;
        int totalStates = game.getActivePsiStates().size();
        
        for (PsiState psiState : game.getActivePsiStates()) {
            String ownerHero = psiState.getOwnerHero();
            if (ownerHero != null) {
                Hero hero = game.getHeroByName(ownerHero);
                if (hero != null) {
                    List<String> immunities = grofiHeroService.getHeroImmunities(hero);
                    if (immunities.contains("OBS") || immunities.contains("COLLAPSE")) {
                        protectedStates++;
                    }
                }
            }
        }
        
        if (protectedStates == totalStates && totalStates > 0) {
            result.put("allowed", false);
            result.put("reason", "Tous les √©tats quantiques sont prot√©g√©s par des immunit√©s");
        } else {
            result.put("allowed", true);
            result.put("protectedStates", protectedStates);
            result.put("totalStates", totalStates);
            result.put("message", "Collapse partiel autoris√© (" + (totalStates - protectedStates) + "/" + totalStates + " √©tats)");
        }
        
        return result;
    }
    
    /**
     * V√©rifier immunit√©s pour Conditions
     */
    private Map<String, Object> checkConditionImmunities(Game game, ExtendedScriptResult parseResult) {
        Map<String, Object> result = new HashMap<>();
        result.put("allowed", true);
        result.put("message", "Conditions GROFI autoris√©es (pas de restrictions)");
        return result;
    }
    
    /**
     * Calculer l'impact sur le graphe causale
     */
    private Map<String, Object> calculateCausalGraphImpact(Game game, ExtendedScriptResult parseResult) {
        Map<String, Object> impact = new HashMap<>();
        
        // Analyser l'impact selon le type
        switch (parseResult.type) {
            case "GROFI_ULTIMATE":
                impact = calculateUltimatePowerCausalImpact(game, parseResult);
                break;
                
            case "ROLLBACK_ALL":
                impact.put("type", "GLOBAL_ROLLBACK");
                impact.put("affectedStates", game.getPsiStates().size());
                impact.put("severity", "HIGH");
                break;
                
            case "TOTAL_COLLAPSE":
                impact.put("type", "TOTAL_COLLAPSE");
                impact.put("affectedStates", game.getActivePsiStates().size());
                impact.put("severity", "CRITICAL");
                break;
                
            default:
                impact.put("type", "MINOR");
                impact.put("severity", "LOW");
        }
        
        // Calculer le stress causale
        double causalStress = calculateCausalStress(game, parseResult);
        impact.put("causalStress", causalStress);
        impact.put("stressLevel", causalStress > 0.8 ? "CRITICAL" : causalStress > 0.5 ? "HIGH" : "NORMAL");
        
        return impact;
    }
    
    /**
     * Calculer l'impact causale d'un Ultimate Power
     */
    private Map<String, Object> calculateUltimatePowerCausalImpact(Game game, ExtendedScriptResult parseResult) {
        Map<String, Object> impact = new HashMap<>();
        
        String freezeTarget = (String) parseResult.parameters.get("freezeTarget");
        
        if ("all.timeline.superposition".equals(freezeTarget)) {
            // Jean-Grofignon's Collapse Override
            int activeStates = game.getActivePsiStates().size();
            impact.put("type", "SUPERPOSITION_FREEZE");
            impact.put("affectedStates", activeStates);
            impact.put("severity", activeStates > 10 ? "HIGH" : "MEDIUM");
            impact.put("description", "Freeze de " + activeStates + " superpositions temporelles");
        } else {
            impact.put("type", "UNKNOWN_ULTIMATE");
            impact.put("severity", "MEDIUM");
        }
        
        return impact;
    }
    
    /**
     * Calculer le stress causale
     */
    private double calculateCausalStress(Game game, ExtendedScriptResult parseResult) {
        // Facteurs de stress
        double baseStress = 0.0;
        
        // Nombre d'√©tats quantiques actifs
        int activeStates = game.getActivePsiStates().size();
        baseStress += activeStates * 0.05; // 5% par √©tat actif
        
        // Type d'action GROFI
        switch (parseResult.type) {
            case "TOTAL_COLLAPSE":
                baseStress += 0.8; // Tr√®s stressant
                break;
            case "ROLLBACK_ALL":
                baseStress += 0.6; // Assez stressant
                break;
            case "GROFI_ULTIMATE":
                baseStress += 0.4; // Mod√©r√©ment stressant
                break;
            case "SYSTEM_INSTABILITY":
                baseStress += 0.3;
                break;
            default:
                baseStress += 0.1; // Stress minimal
        }
        
        // Limiter entre 0 et 1
        return Math.min(1.0, baseStress);
    }
    
    /**
     * Ex√©cuter avec protection causale
     */
    private Map<String, Object> executeWithCausalProtection(Game game, ExtendedScriptResult parseResult) {
        Map<String, Object> result = new HashMap<>();
        
        try {
            // Sauvegarder l'√©tat avant ex√©cution
            Map<String, Object> preExecutionState = captureGameState(game);
            
            // Ex√©cuter l'action GROFI
            Map<String, Object> executionResult = executeGrofiAction(game, parseResult);
            
            // V√©rifier la coh√©rence causale apr√®s ex√©cution
            Map<String, Object> coherenceCheck = verifyCausalCoherence(game, preExecutionState);
            
            result.putAll(executionResult);
            result.put("causalCoherence", coherenceCheck);
            
            // Si incoh√©rence d√©tect√©e, d√©clencher correction automatique
            if (!Boolean.TRUE.equals(coherenceCheck.get("coherent"))) {
                Map<String, Object> correction = applyCausalCorrection(game, preExecutionState);
                result.put("causalCorrection", correction);
            }
            
        } catch (Exception e) {
            result.put("success", false);
            result.put("error", "Erreur protection causale: " + e.getMessage());
        }
        
        return result;
    }
    
    /**
     * Capturer l'√©tat du jeu
     */
    private Map<String, Object> captureGameState(Game game) {
        Map<String, Object> state = new HashMap<>();
        state.put("turn", game.getCurrentTurn());
        state.put("activeStates", game.getActivePsiStates().size());
        state.put("heroPositions", game.getHeroes().stream()
            .collect(Collectors.toMap(
                Hero::getName,
                hero -> Map.of("x", hero.getPositionX(), "y", hero.getPositionY())
            )));
        return state;
    }
    
    /**
     * Ex√©cuter une action GROFI (impl√©mentation simplifi√©e)
     */
    private Map<String, Object> executeGrofiAction(Game game, ExtendedScriptResult parseResult) {
        Map<String, Object> result = new HashMap<>();
        
        // Mock de l'ex√©cution - dans la r√©alit√©, cela appellerait ExtendedTemporalEngineService
        result.put("success", true);
        result.put("actionExecuted", parseResult.type);
        result.put("description", parseResult.description);
        
        return result;
    }
    
    /**
     * V√©rifier la coh√©rence causale
     */
    private Map<String, Object> verifyCausalCoherence(Game game, Map<String, Object> preState) {
        Map<String, Object> result = new HashMap<>();
        
        // V√©rifications de coh√©rence
        boolean coherent = true;
        List<String> violations = new ArrayList<>();
        
        // V√©rifier que le temps n'a pas recul√© de mani√®re incoh√©rente
        int preTurn = (Integer) preState.get("turn");
        if (game.getCurrentTurn() < preTurn) {
            coherent = false;
            violations.add("Temporal regression detected");
        }
        
        // V√©rifier les paradoxes de position
        @SuppressWarnings("unchecked")
        Map<String, Map<String, Object>> prePositions = 
            (Map<String, Map<String, Object>>) preState.get("heroPositions");
        
        for (Hero hero : game.getHeroes()) {
            Map<String, Object> prePos = prePositions.get(hero.getName());
            if (prePos != null) {
                int preX = (Integer) prePos.get("x");
                int preY = (Integer) prePos.get("y");
                
                // V√©rifier les t√©l√©portations impossibles
                int distance = Math.abs(hero.getPositionX() - preX) + Math.abs(hero.getPositionY() - preY);
                if (distance > hero.getMovementPoints() * 2) {
                    violations.add("Impossible teleportation: " + hero.getName());
                }
            }
        }
        
        result.put("coherent", coherent && violations.isEmpty());
        result.put("violations", violations);
        
        return result;
    }
    
    /**
     * Appliquer une correction causale
     */
    private Map<String, Object> applyCausalCorrection(Game game, Map<String, Object> preState) {
        Map<String, Object> result = new HashMap<>();
        
        // Impl√©mentation simplifi√©e de correction
        result.put("correctionApplied", true);
        result.put("method", "Temporal stabilization");
        result.put("message", "Coh√©rence causale restaur√©e");
        
        return result;
    }
    
    /**
     * Traiter les collapses causales d√©clench√©s
     */
    private List<CausalCollapseService.CollapseResult> processTriggeredCausalCollapses(
            Game game, ExtendedScriptResult parseResult) {
        
        // D√©clencher le syst√®me de collapse causale existant
        return causalCollapseService.processAllCausalCollapses(game);
    }
    
    /**
     * Mettre √† jour le graphe d'√©tat du monde
     */
    private void updateWorldStateGraph(Game game, ExtendedScriptResult parseResult, 
                                     Map<String, Object> executionResult) {
        
        // üåê WORLD STATE GRAPH - Impl√©mentation compl√®te
        WorldStateGraph worldGraph = buildWorldStateGraph(game);
        
        // üå´Ô∏è Calculer le fog of causality
        Map<String, Double> fogOfCausality = calculateFogOfCausality(game, worldGraph);
        
        // üìä Mettre √† jour les m√©triques GROFI
        updateGrofiMetrics(game, worldGraph, fogOfCausality);
        
        // üéõÔ∏è Pr√©parer les donn√©es pour PANOPTICŒ©N
        preparePanopticonData(game, worldGraph, fogOfCausality);
        
        System.out.println("üåê World State Graph updated: " + parseResult.type + 
                          " | Fog zones: " + fogOfCausality.size() +
                          " | Causal stability: " + worldGraph.getCausalStability());
    }
    
    /**
     * Construire le graphe d'√©tat du monde complet
     */
    private WorldStateGraph buildWorldStateGraph(Game game) {
        WorldStateGraph graph = new WorldStateGraph();
        
        // üéØ N≈ìuds spatiaux : H√©ros, b√¢timents, artefacts
        for (Hero hero : game.getHeroes()) {
            SpatialNode heroNode = new SpatialNode(
                "hero_" + hero.getName(),
                hero.getPositionX(), hero.getPositionY(), 0,
                game.getCurrentTimeline(), 0,
                SpatialNode.NodeType.HERO,
                grofiHeroService.isGrofiHero(hero) ? "grofi" : "standard"
            );
            graph.addSpatialNode(heroNode);
        }
        
        // üåÄ √âtats quantiques actifs
        for (PsiState psi : game.getActivePsiStates()) {
            if (psi.getTargetX() != null && psi.getTargetY() != null) {
                SpatialNode psiNode = new SpatialNode(
                    "psi_" + psi.getPsiId(),
                    psi.getTargetX(), psi.getTargetY(), 0,
                    psi.getBranchId(), psi.getDeltaT(),
                    SpatialNode.NodeType.PSI_STATE,
                    psi.getActionType()
                );
                psiNode.setProbability(psi.getProbability());
                psiNode.setQuantumState(true);
                graph.addSpatialNode(psiNode);
            }
        }
        
        // üîó Connexions causales
        buildCausalConnections(graph, game);
        
        // ‚è±Ô∏è Couches temporelles
        buildTemporalLayers(graph, game);
        
        return graph;
    }
    
    /**
     * Calculer le fog of causality pour chaque zone
     */
    private Map<String, Double> calculateFogOfCausality(Game game, WorldStateGraph worldGraph) {
        Map<String, Double> fogMap = new HashMap<>();
        
        // üìè Grille de calcul (par zones de 5x5)
        int mapWidth = game.getMapWidth();
        int mapHeight = game.getMapHeight();
        
        for (int x = 0; x < mapWidth; x += 5) {
            for (int y = 0; y < mapHeight; y += 5) {
                String zoneKey = x + "," + y;
                double fogValue = calculateZoneFogOfCausality(x, y, worldGraph, game);
                fogMap.put(zoneKey, fogValue);
            }
        }
        
        return fogMap;
    }
    
    /**
     * Calculer le fog of causality pour une zone sp√©cifique
     */
    private double calculateZoneFogOfCausality(int centerX, int centerY, 
                                             WorldStateGraph worldGraph, Game game) {
        double fogValue = 0.0;
        int radius = 5;
        
        // üåÄ Facteur 1: Densit√© d'√©tats quantiques
        List<SpatialNode> quantumNodes = worldGraph.getNodesInRadius(centerX, centerY, radius)
            .stream()
            .filter(SpatialNode::isQuantumState)
            .collect(Collectors.toList());
        
        double quantumDensity = quantumNodes.size() * 0.2;
        
        // ‚öîÔ∏è Facteur 2: Conflits causals d√©tect√©s
        List<CausalCollapseService.CollapseResult> nearbyConflicts = 
            causalCollapseService.getConflictsInRadius(game, centerX, centerY, radius);
        
        double conflictIntensity = nearbyConflicts.size() * 0.3;
        
        // üîÆ Facteur 3: Interf√©rences quantiques
        double interferenceLevel = 0.0;
        if (quantumNodes.size() > 1) {
            interferenceLevel = quantumInterferenceService
                .calculateInterferenceAtPosition(game, centerX, centerY)
                .getCombinedProbability() * 0.25;
        }
        
        // üè∞ Facteur 4: Proximit√© d'artefacts temporels
        double artifactInfluence = calculateArtifactInfluence(centerX, centerY, game);
        
        // üëÅÔ∏è Facteur 5: Observation r√©cente (r√©duit le fog)
        double observationClarity = calculateObservationClarity(centerX, centerY, game);
        
        // üìä Formule finale du fog of causality
        fogValue = (quantumDensity + conflictIntensity + interferenceLevel + artifactInfluence) 
                  * (1.0 - observationClarity);
        
        // üìè Normaliser entre 0.0 et 1.0
        return Math.max(0.0, Math.min(1.0, fogValue));
    }
    
    /**
     * Calculer l'influence des artefacts temporels sur le fog
     */
    private double calculateArtifactInfluence(int x, int y, Game game) {
        double influence = 0.0;
        
        // V√©rifier les artefacts l√©gendaires actifs
        for (Hero hero : game.getHeroes()) {
            double distance = Math.sqrt(Math.pow(hero.getPositionX() - x, 2) + 
                                       Math.pow(hero.getPositionY() - y, 2));
            
            if (distance <= 10) { // Rayon d'influence des artefacts
                // Analyser l'inventaire du h√©ros pour artefacts temporels
                for (String item : hero.getInventory()) {
                    if (item.contains("AvantWorldBlade")) {
                        influence += 0.4 * (1.0 - distance / 10.0);
                    } else if (item.contains("EyeOfWigner")) {
                        influence += 0.3 * (1.0 - distance / 10.0);
                    } else if (item.contains("TemporalAnchor")) {
                        influence -= 0.2 * (1.0 - distance / 10.0); // Anchor r√©duit le fog
                    }
                }
            }
        }
        
        return Math.max(0.0, influence);
    }
    
    /**
     * Calculer la clart√© due aux observations r√©centes
     */
    private double calculateObservationClarity(int x, int y, Game game) {
        double clarity = 0.0;
        
        // Les collapses r√©cents r√©duisent le fog (r√©alit√© stabilis√©e)
        List<PsiState> recentCollapses = game.getPsiStates().stream()
            .filter(psi -> !psi.isActive() && psi.getTargetX() != null && psi.getTargetY() != null)
            .filter(psi -> {
                double distance = Math.sqrt(Math.pow(psi.getTargetX() - x, 2) + 
                                           Math.pow(psi.getTargetY() - y, 2));
                return distance <= 8; // Rayon de clart√©
            })
            .collect(Collectors.toList());
        
        clarity = Math.min(0.5, recentCollapses.size() * 0.1);
        
        return clarity;
    }
    
    /**
     * Construire les connexions causales dans le graphe
     */
    private void buildCausalConnections(WorldStateGraph graph, Game game) {
        List<SpatialNode> allNodes = graph.getAllNodes();
        
        for (SpatialNode node1 : allNodes) {
            for (SpatialNode node2 : allNodes) {
                if (node1 != node2 && hasCausalConnection(node1, node2, game)) {
                    CausalConnection connection = new CausalConnection(
                        node1.getId(), node2.getId(),
                        calculateConnectionStrength(node1, node2),
                        determineCausalType(node1, node2)
                    );
                    graph.addCausalConnection(connection);
                }
            }
        }
    }
    
    /**
     * V√©rifier s'il existe une connexion causale entre deux n≈ìuds
     */
    private boolean hasCausalConnection(SpatialNode node1, SpatialNode node2, Game game) {
        // Connexion si m√™me position ou positions adjacentes
        double distance = Math.sqrt(Math.pow(node1.getX() - node2.getX(), 2) + 
                                   Math.pow(node1.getY() - node2.getY(), 2));
        
        if (distance <= 3) return true; // Connexions locales
        
        // Connexion si m√™me timeline et layer temporel proche
        if (node1.getTimeline().equals(node2.getTimeline()) && 
            Math.abs(node1.getTemporalLayer() - node2.getTemporalLayer()) <= 1) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Construire les couches temporelles
     */
    private void buildTemporalLayers(WorldStateGraph graph, Game game) {
        Map<Integer, List<SpatialNode>> layerMap = new HashMap<>();
        
        // Grouper les n≈ìuds par couche temporelle
        for (SpatialNode node : graph.getAllNodes()) {
            layerMap.computeIfAbsent(node.getTemporalLayer(), k -> new ArrayList<>())
                   .add(node);
        }
        
        // Cr√©er les couches temporelles
        for (Map.Entry<Integer, List<SpatialNode>> entry : layerMap.entrySet()) {
            TemporalLayer layer = new TemporalLayer(
                entry.getKey(),
                game.getCurrentTimeline(),
                entry.getValue()
            );
            graph.addTemporalLayer(layer);
        }
    }
    
    /**
     * Mettre √† jour les m√©triques GROFI avec le World State Graph
     */
    private void updateGrofiMetrics(Game game, WorldStateGraph worldGraph, 
                                   Map<String, Double> fogOfCausality) {
        // Calculer les m√©triques avanc√©es pour GROFI
        double avgFogLevel = fogOfCausality.values().stream()
            .mapToDouble(Double::doubleValue)
            .average()
            .orElse(0.0);
        
        int highFogZones = (int) fogOfCausality.values().stream()
            .mapToDouble(Double::doubleValue)
            .filter(fog -> fog > 0.7)
            .count();
        
        // Stocker dans le contexte GROFI pour prise de d√©cision
        Map<String, Object> grofiContext = new HashMap<>();
        grofiContext.put("avgFogOfCausality", avgFogLevel);
        grofiContext.put("highFogZones", highFogZones);
        grofiContext.put("totalCausalConnections", worldGraph.getCausalConnections().size());
        grofiContext.put("quantumNodeCount", worldGraph.getQuantumNodes().size());
        grofiContext.put("causalStability", worldGraph.getCausalStability());
        
        // Int√©grer avec le service GROFI existant
        grofiHeroService.updateWorldContext(grofiContext);
    }
    
    /**
     * Pr√©parer les donn√©es pour le PANOPTICŒ©N
     */
    private void preparePanopticonData(Game game, WorldStateGraph worldGraph, 
                                      Map<String, Double> fogOfCausality) {
        // Cr√©er la structure de donn√©es pour le visualiseur
        Map<String, Object> panopticonData = new HashMap<>();
        
        panopticonData.put("spatialNodes", worldGraph.getAllNodes());
        panopticonData.put("causalConnections", worldGraph.getCausalConnections());
        panopticonData.put("temporalLayers", worldGraph.getTemporalLayers());
        panopticonData.put("fogOfCausality", fogOfCausality);
        panopticonData.put("gameId", game.getId());
        panopticonData.put("currentTurn", game.getCurrentTurn());
        panopticonData.put("timeline", game.getCurrentTimeline());
        
        // Stocker pour r√©cup√©ration par l'API PANOPTICŒ©N
        // (Impl√©mentation du cache ou service de donn√©es √† ajouter)
        System.out.println("üìä PANOPTICŒ©N data prepared: " + 
                          worldGraph.getAllNodes().size() + " nodes, " +
                          worldGraph.getCausalConnections().size() + " connections");
    }
    
    /**
     * Obtenir les statistiques d'int√©gration GROFI-causale
     */
    public Map<String, Object> getGrofiCausalStatistics(Game game) {
        Map<String, Object> stats = new HashMap<>();
        
        // Statistiques de base
        stats.put("totalHeroes", game.getHeroes().size());
        stats.put("grofiHeroes", game.getHeroes().stream()
            .mapToLong(hero -> grofiHeroService.isGrofiHero(hero) ? 1 : 0)
            .sum());
        stats.put("activeStates", game.getActivePsiStates().size());
        
        // Immunit√©s actives
        Map<String, Integer> immunityCount = new HashMap<>();
        for (Hero hero : game.getHeroes()) {
            List<String> immunities = grofiHeroService.getHeroImmunities(hero);
            for (String immunity : immunities) {
                immunityCount.merge(immunity, 1, Integer::sum);
            }
        }
        stats.put("activeImmunities", immunityCount);
        
        // Stress causale actuel
        ExtendedScriptResult mockResult = new ExtendedScriptResult();
        mockResult.type = "SYSTEM_CHECK";
        double currentStress = calculateCausalStress(game, mockResult);
        stats.put("causalStress", currentStress);
        stats.put("stressLevel", currentStress > 0.8 ? "CRITICAL" : currentStress > 0.5 ? "HIGH" : "NORMAL");
        
        // Statistiques de collapse causale
        Map<String, Object> collapseStats = causalCollapseService.getCollapseStatistics(game);
        stats.put("collapseStatistics", collapseStats);
        
        return stats;
    }
} 